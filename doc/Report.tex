\documentclass[11pt]{article}

% PACKAGES FOR STYLING AND FUNCTIONALITY
\usepackage{fullpage} % Use more of the page
\usepackage{xcolor}   % For colored text, used in the \todo command
\usepackage{amsmath}  % For advanced math environments and symbols
\usepackage{graphicx} % For including images
% \usepackage{listings} % Recommended for formatting code snippets

% CUSTOM COMMANDS
% A \todo command to leave notes for team members
\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO: #1}}}

% =============================================================================
% DOCUMENT STARTS HERE
% =============================================================================

\begin{document}

% -----------------------------------------------------------------------------
% TITLE PAGE
% -----------------------------------------------------------------------------
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\huge ARMv8 AArch64 â€“ Assembler and Emulator\par}
    
    \vspace{1.5cm}
    
    {\LARGE Final Report\par}
    
    \vspace{0.5cm}
    
    % NOTE: The final report must be a maximum of 6 pages (6 A4 sides).
    % Be concise in your descriptions.
    
    \vfill % Pushes the content below to the bottom
    
    {\Large Team 54\par}
    
    \vspace{1cm}
    
    {\large Date: 20 June 2025\par}
    
    \vspace{1cm}
    
    \textbf{Group Members:}\\
    \begin{large}
        \begin{tabular}{l}
            Member Name 1 \\
            Member Name 2 \\
            Member Name 3 \\
            Member Name 4 \\
        \end{tabular}
    \end{large}

    \vspace*{2cm}
    
\end{titlepage}

% -----------------------------------------------------------------------------
% TABLE OF CONTENTS
% -----------------------------------------------------------------------------
\tableofcontents
\newpage

% -----------------------------------------------------------------------------
% SECTION 1: ASSEMBLER IMPLEMENTATION
% -----------------------------------------------------------------------------
\section{Assembler (Part II) - Design and Implementation}

\subsection{High-Level Design: A Two-Pass Approach}

To handle forward references to labels, we opted for the classic two-pass assembly process, 
simplifying the logic for branch and literal load instructions.

\subsubsection{Pass 1: Symbol Resolution}
In the first pass, the assembler reads the input \texttt{.s} file line-by-line to build a symbol table. 
We maintained a program counter, starting at address zero, which was incremented by four for each instruction or \texttt{.int} 
directive encountered. When a token ending in a colon (\texttt{:}) was found, 
we stripped the colon and added the resulting label along with the address to our symbol table. 

Our data structure of choice for the symbol table was a simple linked list, where each node contained the label,
its corresponding address, and a pointer to the next node. We opted for this data structure due to its simplicity, 
memory and insertion efficiency, and ease of implementation.  


\subsubsection{Pass 2: Code Generation}
The second pass rereads the \texttt{.s} file, this time with a complete symbol table. 
For each line, we invoke the tokenizer to break it into its components. 
A central if-else structure then inspects the mnemonic (the first token) to call the appropriate assembly function 
(e.g., \texttt{assemble\_dp}, \texttt{assemble\_ldr}, \texttt{assemble\_b}). 
The resulting 32-bit instruction word is then written to the output binary file using \texttt{fwrite} in little-endian format.

\subsection{Key Implementation Modules}

\subsubsection{Tokenizer}
Our initial implementation treated chunks like \texttt{[Xn, \#imm]} as single tokens. 
This proved impractical as it made parsing the varied data transfer addressing modes too complex. 
We refactored the tokenizer to treat special characters (\texttt{[}, \texttt{]}, \texttt{,}, \texttt{\#}, \texttt{!}) as individual tokens. 
This change created a more predictable and granular token stream,
which significantly simplified the logic in our data transfer and data processing instruction assemblers.

For the implementation, we used a simple resizing array for memory efficiency.
We first skip any whitespace, then save the start of the token, and finally continue until we hit a whitespace or special character.
Then we extract the token based on the start and current pointer and add it to the array.

\subsubsection{Data Processing (DP) Instructions}
To handle the large number of DP mnemonics, we implemented a lookup table that maps each mnemonic to one of ten DP mnemonic "types" 
(e.g., \texttt{ARITH}, \texttt{LOGICAL}, \texttt{MOVX}, etc.), based on the categorization found in Table 2 of the spec.
For each type, we wrote a dedicated assembly function that handles the specific encoding logic. 
This modular approach allowed us to easily handle mnemonic aliases, for example, the instruction \texttt{mul rd, rn, rm} is 
assembled by passing the appropriate tokens to the assembly function for instructions of type \texttt{madd rd, rn, rm, rzr}.

We also implemented a number of helper utility functions such as \texttt{set\_bits} to make the encoding logic cleaner and more maintainable
and \texttt{get\_register\_number} to avoid duplicate code when converting register names to their corresponding numbers.

We encountered a challenge of many tests failing which we traced back to the handling of tokens by the DP assembler. 
The initial implementation assumed the first, less granular version of the tokenizer.
After refactoring the DP assembler to work with the correct tokenizer, we fixed around 570 test cases, leaving only a few DP-unrelated tests failing.

\subsubsection{Data Transfer (LDR/STR) Instructions}
The data transfer instructions were the most complex to implement due to their varied and flexible addressing modes. Our improved tokenizer was essential here. By examining the pattern of tokens---such as the presence of an exclamation mark for pre/post-indexing or the number of tokens between the square brackets---we could reliably distinguish between the different addressing formats and call the correct assembly logic.
\todo{Elaborate on one specific addressing mode (e.g., pre-indexed) and how the token stream was parsed to assemble it correctly.}

\subsubsection{Branch Instructions}
The core logic for assembling branch instructions is the calculation of the branch offset from a label. The offset is calculated using the formula: \texttt{offset = (target\_address - current\_instruction\_address) / 4}. We ensured our implementation correctly handled this as a signed, 4-byte-aligned, word-based offset. The target address was retrieved from the symbol table built in the first pass. 
\todo{Confirm that your code correctly handles the sign extension for the simm19 (B.cond) and simm26 (B) fields.}


% -----------------------------------------------------------------------------
% SECTION 2: RASPBERRY PI IMPLEMENTATION
% -----------------------------------------------------------------------------
\section{Raspberry Pi (Part III)}

\subsection{Assembly Program Design (led\_blink.s)}
Our assembly program, \texttt{led\_blink.s} used to blink an LED on the Raspberry Pi works as follows:
\begin{itemize}
    \item Load the base address of the GPIO peripheral registers into a register.
    \item Configure the target GPIO pin (e.g., GPIO 21) as an output by writing the bit pattern \texttt{001} to the appropriate bits in the GPFSEL2 register.
    \item Enter an infinite loop labelled \texttt{main\_loop:}.
    \item Turn the LED on by writing to the GPSET0 register.
    \item Implement a delay using a nested loop that decrements a register a large number of times.
    \item Turn the LED off by writing to the GPCLR0 register.
    \item Implement another delay.
    \item Use an unconditional branch (\texttt{b main\_loop}) to repeat the cycle indefinitely.
\end{itemize}

\subsection{Challenges}
Our emulator and assembler both passed all tests, but we faced challenges when deploying the assembly program to the Raspberry Pi.
The main issue was that connecting the SD card containing the assembled 
\texttt{kernel8.img} file did not flash the LED as expected.
At first, we thought the issue was with the hardware, but after connecting the LED to the steady 5V pin, 
we confirmed that the LED and the GPIO pin were functioning correctly.
In the end, we discovered that we were connecting the SD card to the Raspberry Pi incorrectly;
we were plugging in the USB card reader into a USB port instead of the SD card itself into the SD card slot.
After correcting this, the LED started blinking as expected.


% -----------------------------------------------------------------------------
% SECTION 3: THE EXTENSION
% -----------------------------------------------------------------------------
\section{The Extension}

\subsection{Description and Goal}
\todo{State the high-level purpose of your extension. What new capability did you add to the assembler or emulator? (e.g., support for floating-point instructions, a new pseudo-instruction, an interactive debugger feature, etc.)}

\subsection{Design and Implementation}
\todo{Describe how you designed and implemented the extension. What new data structures, parsing logic, or execution logic were required? How did it integrate with your existing assembler/emulator codebase?}

\subsection{Example of Use}
\todo{Provide a short, concrete example of your extension in action. This could be a snippet of assembly code that uses your new feature, a screenshot of your new emulator command, or a description of an input and its corresponding output. Explain what the example demonstrates.}

\subsection{Challenges and Learning}
\todo{What was the most challenging part of implementing the extension? What key problems did you have to overcome? What did you learn from the process?}


% -----------------------------------------------------------------------------
% SECTION 4: TESTING STRATEGY
% -----------------------------------------------------------------------------
\section{Testing Strategy}

\subsection{Assembler Testing}
\todo{Describe how you tested the assembler. Did you use the provided test suite? Did you write your own unit tests or assembly files? Mention specific cases you focused on (e.g., forward/backward branches, all addressing modes, instruction aliases, edge cases).}

\subsection{Raspberry Pi and Extension Testing}
\todo{Explain how you verified the correctness of your LED blinking program and your extension. For the Pi, describe the process of deploying and observing the result. For the extension, describe the specific tests you wrote or ran to ensure it worked as intended.}

\subsection{Effectiveness of Testing}
\todo{Discuss how effective you believe your testing strategy was. Did it catch most bugs early? Were there any classes of bugs that your tests missed? What would you do to improve your testing process in the future?}


% -----------------------------------------------------------------------------
% SECTION 5: GROUP REFLECTION
% -----------------------------------------------------------------------------
\section{Group Reflection}
\todo{Write a reflection on your experience working as a group. Discuss your methods for communication (e.g., Discord, regular meetings) and for splitting up work (e.g., by feature, pair programming). Critically evaluate how effective these methods were. What would you keep the same for a future group project, and what would you do differently?}


% -----------------------------------------------------------------------------
% SECTION 6: INDIVIDUAL REFLECTIONS
% -----------------------------------------------------------------------------
\section{Individual Reflections}
\subsection{Reflection from Richard}
I feel like I made solid contribution to our project, especially in fixing most of the failing test cases and implementing the 
instruction decoding and data processing assembly. I also spent a fair bit of time reviewing merge requests, which proved tricky 
when the branches were large but I tried to stay as thorough as possible. Overall, I think my strengths lied in problem-solving and 
consistency. If I were to do anything differently, it would be to allocate more time to complex code 
reviews to avoid potential oversights. I've learned a lot from this project and will definitely carry that forward into future group work.

\subsection{Reflection from <Member Name 2>}
\todo{Write at least one paragraph reflecting on your personal contribution and experience. Use feedback from your peer assessment. What were your strengths and weaknesses? How did this compare to your expectations? What would you do differently or continue to do when working in future groups?}

\subsection{Reflection from <Member Name 3>}
\todo{Write at least one paragraph reflecting on your personal contribution and experience. Use feedback from your peer assessment. What were your strengths and weaknesses? How did this compare to your expectations? What would you do differently or continue to do when working in future groups?}

\subsection{Reflection from <Member Name 4>}
\todo{Write at least one paragraph reflecting on your personal contribution and experience. Use feedback from your peer assessment. What were your strengths and weaknesses? How did this compare to your expectations? What would you do differently or continue to do when working in future groups?}

\end{document}