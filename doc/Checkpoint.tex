\documentclass[11pt,a4paper]{article} % A4paper option

\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{enumitem} % For more control over lists, helpful for readability
\usepackage{seqsplit} % For breaking long sequences of text

% Defines a command for TODOs to make them stand out in draft
\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO: #1}}}

\begin{document}

\title{ARMv8 AArch64 Emulator Checkpoint Report}
\author{Team 54}

\maketitle

\section{Group Organisation and Workflow}
\label{sec:group-organisation}

Our group used a structured workflow and leveraged Git with dedicated \texttt{feat/} branches and frequent stub implementations to maintain code quality and compilation. Commit messages followed an imperative format with contributor shortcodes. Every new feature created a GitLab merge request which was reviewed and approved by a separate team member to uphold coding standards.

\subsection{Division of Labour for Emulator (Part I)}
The emulator development was systematically divided into four core components, ensuring balanced responsibilities across the team:

\begin{itemize}[leftmargin=1.5em,noitemsep, itemsep=0.5em, parsep=0em]
    \item \textbf{Jai -- Core System \& I/O:}\\
    Established the emulator's core infrastructure by defining \texttt{ARMState} (registers, PC, PSTATE, memory), initialising its state, implementing the binary file loader, and managing the main execution loop, including command-line parsing, halt instruction, and final output.
    \item \textbf{Richard -- Instruction Decoding \& Bitwise Utilities:}\\
    Led instruction decoding by developing bit extraction utilities, defining C structures (\texttt{\seqsplit{instruction\_types.h}}) for decoded instructions, implementing \texttt{decode\_instruction}, and creating helpers for \texttt{PSTATE} flag updates and register ID mapping.
    \item \textbf{Prasanna -- Data Processing Instructions Execution:}\\
    Implemented the execution logic for all data processing instructions (arithmetic, wide moves, logical, multiplies), developed underlying bitwise shift functions, and integrated \texttt{PSTATE} flag updates.
    \item \textbf{Zayan -- Memory \& Control Flow Instructions Execution:}\\
    Implemented memory access and control flow instructions, including single data transfers (\texttt{ldr}, \texttt{str}) with all addressing modes and load/store size handling, and developed all branch instructions for PC modification, offset calculations, and conditional execution. \todo{For Part III, Zayan will integrate GPIO memory write detection here.}
\end{itemize}

\section{Group Progress and Communication}
\label{sec:group-progress}

Our group is working well together thus far, showing strong individual performance as well as good mutual support. We have elected Jai as our group leader, to manage the workflow and decide how the project will be split between members of the group. Initially, we split the emulator task into 4 roughly equal components and developed group standards for git commit messages, branch names, and comment styles. Communicating through a Slack channel, we organise frequent meetings (approximately every other day) to ensure that each team member is continuing to stay on track with their assigned work. A key practice for us has been to pair up for merge commits so that we can peer review eachother’s code for quality and catch any potential issues. 

For later parts of the project, we can see our current communication standards continuing majorly as they are. We feel that in future tasks (the assembler and extension) there will be more interdependencies on eachother’s code, so integration tasks will pose a greater challenge, yet we feel confident that our established communication standards and peer review process should suffice.

\section{Emulator Structure and Reusability}
\label{sec:emulator-structure}
\subsection*{Emulator Architecture and Reusability for Assembler}

Our emulator is structured around a standard Fetch-Decode-Execute cycle, operating on a shared \texttt{ARMState} struct that represents the machine's current state. This struct includes an array of 64-bit general-purpose registers (\texttt{registers[31]}), the program counter (\texttt{pc}), a \texttt{PSTATE} struct holding the NZCV flags as bools, and a 2MB byte-addressable memory array.\\

The fetch phase reads 32-bit A64 instructions from memory using the current PC. The decode phase identifies the instruction category using bits 25–28 and extracts relevant fields using bitwise operations, with the help of reusable utility functions (e.g., \texttt{get\_bits()}). A decoded instruction is represented by a \texttt{DecodedInstruction} struct which includes the instruction type as an enum \texttt{type}, a 32-bit \texttt{raw\_instruction} and members for the various instruction-specific fields (e.g., \texttt{dp\_imm\_imm12}). The execute phase performs the instruction logic using helper modules for arithmetic, memory access, or branching, updating the \texttt{ARMState} accordingly and incrementing the PC.\\

Several components of the emulator will be reusable in the assembler, especially the instruction decoding logic and its bit extraction and field parsing logic, which can be reverse engineered to help us generate binary encodings from assembly syntax. Additionally, functions that map register names to IDs and handle 32-bit versus 64-bit register size will be useful when parsing operands.

\section{Challenges and Mitigation}
\label{sec:challenges}
During the emulator's implementation, several technical and collaborative challenges were encountered. From a technical standpoint, accurately translating ARMv8 AArch64's intricate instruction set into C required meticulous attention to detail, particularly with bitwise operations. Implementing the \texttt{ASR} and \texttt{ROR} shifts, for instance, demanded careful consideration of signed bit propagation and rotation across both 32-bit and 64-bit operand widths, which was mitigated by breaking down the logic into smaller, testable functions and consulting the ARM Architectural Reference Manual extensively. Similarly, correctly calculating and updating the \texttt{PSTATE} flags (\texttt{N}, \texttt{Z}, \texttt{C}, \texttt{V}) for arithmetic and logical operations presented a significant hurdle, as their rules vary based on instruction type and operand properties. This was addressed through iterative development, isolated test cases for flag behaviour, and collaborative cross-checking of the logic.

Collaboratively, integrating code from four parallel development streams posed challenges related to dependencies and potential merge conflicts. Our strategy of defining clear interfaces in shared header files (\texttt{arm\_state.h}, \texttt{instruction\_types.h}) early in the project proved invaluable, minimizing friction during integration. We adopted a disciplined Git workflow, leveraging frequent `git pull --rebase` operations on feature branches to keep them synchronized with the `master` branch, which helped manage potential divergences. When unexpected push failures occurred, understanding the underlying cause (e.g., divergent history) and employing commands like `git push --force-with-lease` after a successful rebase became essential. Debugging the interactions between different instruction types and memory operations often involved extensive use of `gdb` and strategic `fprintf` statements to trace the program counter, register values, and memory state, providing crucial insights into execution flow anomalies.
\end{document}